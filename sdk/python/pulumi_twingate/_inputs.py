# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ProviderCacheArgs',
    'ProviderCacheArgsDict',
    'ProviderCacheGroupsFilterArgs',
    'ProviderCacheGroupsFilterArgsDict',
    'ProviderCacheResourcesFilterArgs',
    'ProviderCacheResourcesFilterArgsDict',
    'ProviderDefaultTagsArgs',
    'ProviderDefaultTagsArgsDict',
    'TwingateDNSFilteringProfileAllowedDomainsArgs',
    'TwingateDNSFilteringProfileAllowedDomainsArgsDict',
    'TwingateDNSFilteringProfileContentCategoriesArgs',
    'TwingateDNSFilteringProfileContentCategoriesArgsDict',
    'TwingateDNSFilteringProfileDeniedDomainsArgs',
    'TwingateDNSFilteringProfileDeniedDomainsArgsDict',
    'TwingateDNSFilteringProfilePrivacyCategoriesArgs',
    'TwingateDNSFilteringProfilePrivacyCategoriesArgsDict',
    'TwingateDNSFilteringProfileSecurityCategoriesArgs',
    'TwingateDNSFilteringProfileSecurityCategoriesArgsDict',
    'TwingateResourceAccessGroupArgs',
    'TwingateResourceAccessGroupArgsDict',
    'TwingateResourceAccessGroupAccessPolicyArgs',
    'TwingateResourceAccessGroupAccessPolicyArgsDict',
    'TwingateResourceAccessPolicyArgs',
    'TwingateResourceAccessPolicyArgsDict',
    'TwingateResourceAccessServiceArgs',
    'TwingateResourceAccessServiceArgsDict',
    'TwingateResourceProtocolsArgs',
    'TwingateResourceProtocolsArgsDict',
    'TwingateResourceProtocolsTcpArgs',
    'TwingateResourceProtocolsTcpArgsDict',
    'TwingateResourceProtocolsUdpArgs',
    'TwingateResourceProtocolsUdpArgsDict',
    'GetTwingateDNSFilteringProfileAllowedDomainsArgs',
    'GetTwingateDNSFilteringProfileAllowedDomainsArgsDict',
    'GetTwingateDNSFilteringProfileContentCategoriesArgs',
    'GetTwingateDNSFilteringProfileContentCategoriesArgsDict',
    'GetTwingateDNSFilteringProfileDeniedDomainsArgs',
    'GetTwingateDNSFilteringProfileDeniedDomainsArgsDict',
    'GetTwingateDNSFilteringProfilePrivacyCategoriesArgs',
    'GetTwingateDNSFilteringProfilePrivacyCategoriesArgsDict',
    'GetTwingateDNSFilteringProfileSecurityCategoriesArgs',
    'GetTwingateDNSFilteringProfileSecurityCategoriesArgsDict',
    'GetTwingateResourceProtocolsArgs',
    'GetTwingateResourceProtocolsArgsDict',
    'GetTwingateResourceProtocolsTcpArgs',
    'GetTwingateResourceProtocolsTcpArgsDict',
    'GetTwingateResourceProtocolsUdpArgs',
    'GetTwingateResourceProtocolsUdpArgsDict',
]

MYPY = False

if not MYPY:
    class ProviderCacheArgsDict(TypedDict):
        groups_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the provider should cache groups. The default value is `true`.
        """
        groups_filter: NotRequired[pulumi.Input['ProviderCacheGroupsFilterArgsDict']]
        """
        Specifies the filter for the groups to be cached.
        """
        resource_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the provider should cache resources. The default value is `true`.
        """
        resources_filter: NotRequired[pulumi.Input['ProviderCacheResourcesFilterArgsDict']]
        """
        Specifies the filter for the resources to be cached.
        """
elif False:
    ProviderCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderCacheArgs:
    def __init__(__self__, *,
                 groups_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 groups_filter: Optional[pulumi.Input['ProviderCacheGroupsFilterArgs']] = None,
                 resource_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 resources_filter: Optional[pulumi.Input['ProviderCacheResourcesFilterArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] groups_enabled: Specifies whether the provider should cache groups. The default value is `true`.
        :param pulumi.Input['ProviderCacheGroupsFilterArgs'] groups_filter: Specifies the filter for the groups to be cached.
        :param pulumi.Input[_builtins.bool] resource_enabled: Specifies whether the provider should cache resources. The default value is `true`.
        :param pulumi.Input['ProviderCacheResourcesFilterArgs'] resources_filter: Specifies the filter for the resources to be cached.
        """
        if groups_enabled is not None:
            pulumi.set(__self__, "groups_enabled", groups_enabled)
        if groups_filter is not None:
            pulumi.set(__self__, "groups_filter", groups_filter)
        if resource_enabled is not None:
            pulumi.set(__self__, "resource_enabled", resource_enabled)
        if resources_filter is not None:
            pulumi.set(__self__, "resources_filter", resources_filter)

    @_builtins.property
    @pulumi.getter(name="groupsEnabled")
    def groups_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the provider should cache groups. The default value is `true`.
        """
        return pulumi.get(self, "groups_enabled")

    @groups_enabled.setter
    def groups_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "groups_enabled", value)

    @_builtins.property
    @pulumi.getter(name="groupsFilter")
    def groups_filter(self) -> Optional[pulumi.Input['ProviderCacheGroupsFilterArgs']]:
        """
        Specifies the filter for the groups to be cached.
        """
        return pulumi.get(self, "groups_filter")

    @groups_filter.setter
    def groups_filter(self, value: Optional[pulumi.Input['ProviderCacheGroupsFilterArgs']]):
        pulumi.set(self, "groups_filter", value)

    @_builtins.property
    @pulumi.getter(name="resourceEnabled")
    def resource_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the provider should cache resources. The default value is `true`.
        """
        return pulumi.get(self, "resource_enabled")

    @resource_enabled.setter
    def resource_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "resource_enabled", value)

    @_builtins.property
    @pulumi.getter(name="resourcesFilter")
    def resources_filter(self) -> Optional[pulumi.Input['ProviderCacheResourcesFilterArgs']]:
        """
        Specifies the filter for the resources to be cached.
        """
        return pulumi.get(self, "resources_filter")

    @resources_filter.setter
    def resources_filter(self, value: Optional[pulumi.Input['ProviderCacheResourcesFilterArgs']]):
        pulumi.set(self, "resources_filter", value)


if not MYPY:
    class ProviderCacheGroupsFilterArgsDict(TypedDict):
        is_active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Returns only Groups matching the specified state.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns only groups that exactly match this name. If no options are passed it will return all resources. Only one option can be used at a time.
        """
        name_contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Match when the value exist in the name of the group.
        """
        name_exclude: NotRequired[pulumi.Input[_builtins.str]]
        """
        Match when the exact value does not exist in the name of the group.
        """
        name_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the group must start with the value.
        """
        name_regexp: NotRequired[pulumi.Input[_builtins.str]]
        """
        The regular expression match of the name of the group.
        """
        name_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the group must end with the value.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Returns groups that match a list of types. valid types: `MANUAL`, `SYNCED`, `SYSTEM`.
        """
elif False:
    ProviderCacheGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderCacheGroupsFilterArgs:
    def __init__(__self__, *,
                 is_active: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_contains: Optional[pulumi.Input[_builtins.str]] = None,
                 name_exclude: Optional[pulumi.Input[_builtins.str]] = None,
                 name_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 name_regexp: Optional[pulumi.Input[_builtins.str]] = None,
                 name_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_active: Returns only Groups matching the specified state.
        :param pulumi.Input[_builtins.str] name: Returns only groups that exactly match this name. If no options are passed it will return all resources. Only one option can be used at a time.
        :param pulumi.Input[_builtins.str] name_contains: Match when the value exist in the name of the group.
        :param pulumi.Input[_builtins.str] name_exclude: Match when the exact value does not exist in the name of the group.
        :param pulumi.Input[_builtins.str] name_prefix: The name of the group must start with the value.
        :param pulumi.Input[_builtins.str] name_regexp: The regular expression match of the name of the group.
        :param pulumi.Input[_builtins.str] name_suffix: The name of the group must end with the value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] types: Returns groups that match a list of types. valid types: `MANUAL`, `SYNCED`, `SYSTEM`.
        """
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_contains is not None:
            pulumi.set(__self__, "name_contains", name_contains)
        if name_exclude is not None:
            pulumi.set(__self__, "name_exclude", name_exclude)
        if name_prefix is not None:
            pulumi.set(__self__, "name_prefix", name_prefix)
        if name_regexp is not None:
            pulumi.set(__self__, "name_regexp", name_regexp)
        if name_suffix is not None:
            pulumi.set(__self__, "name_suffix", name_suffix)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Returns only Groups matching the specified state.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_active", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns only groups that exactly match this name. If no options are passed it will return all resources. Only one option can be used at a time.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameContains")
    def name_contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Match when the value exist in the name of the group.
        """
        return pulumi.get(self, "name_contains")

    @name_contains.setter
    def name_contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_contains", value)

    @_builtins.property
    @pulumi.getter(name="nameExclude")
    def name_exclude(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Match when the exact value does not exist in the name of the group.
        """
        return pulumi.get(self, "name_exclude")

    @name_exclude.setter
    def name_exclude(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_exclude", value)

    @_builtins.property
    @pulumi.getter(name="namePrefix")
    def name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the group must start with the value.
        """
        return pulumi.get(self, "name_prefix")

    @name_prefix.setter
    def name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_prefix", value)

    @_builtins.property
    @pulumi.getter(name="nameRegexp")
    def name_regexp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The regular expression match of the name of the group.
        """
        return pulumi.get(self, "name_regexp")

    @name_regexp.setter
    def name_regexp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_regexp", value)

    @_builtins.property
    @pulumi.getter(name="nameSuffix")
    def name_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the group must end with the value.
        """
        return pulumi.get(self, "name_suffix")

    @name_suffix.setter
    def name_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_suffix", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Returns groups that match a list of types. valid types: `MANUAL`, `SYNCED`, `SYSTEM`.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class ProviderCacheResourcesFilterArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns only resources that exactly match this name. If no options are passed it will return all resources. Only one option can be used at a time.
        """
        name_contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Match when the value exist in the name of the resource.
        """
        name_exclude: NotRequired[pulumi.Input[_builtins.str]]
        """
        Match when the exact value does not exist in the name of the resource.
        """
        name_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource must start with the value.
        """
        name_regexp: NotRequired[pulumi.Input[_builtins.str]]
        """
        The regular expression match of the name of the resource.
        """
        name_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource must end with the value.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Returns only resources that exactly match the given tags.
        """
elif False:
    ProviderCacheResourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderCacheResourcesFilterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_contains: Optional[pulumi.Input[_builtins.str]] = None,
                 name_exclude: Optional[pulumi.Input[_builtins.str]] = None,
                 name_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 name_regexp: Optional[pulumi.Input[_builtins.str]] = None,
                 name_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Returns only resources that exactly match this name. If no options are passed it will return all resources. Only one option can be used at a time.
        :param pulumi.Input[_builtins.str] name_contains: Match when the value exist in the name of the resource.
        :param pulumi.Input[_builtins.str] name_exclude: Match when the exact value does not exist in the name of the resource.
        :param pulumi.Input[_builtins.str] name_prefix: The name of the resource must start with the value.
        :param pulumi.Input[_builtins.str] name_regexp: The regular expression match of the name of the resource.
        :param pulumi.Input[_builtins.str] name_suffix: The name of the resource must end with the value.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Returns only resources that exactly match the given tags.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_contains is not None:
            pulumi.set(__self__, "name_contains", name_contains)
        if name_exclude is not None:
            pulumi.set(__self__, "name_exclude", name_exclude)
        if name_prefix is not None:
            pulumi.set(__self__, "name_prefix", name_prefix)
        if name_regexp is not None:
            pulumi.set(__self__, "name_regexp", name_regexp)
        if name_suffix is not None:
            pulumi.set(__self__, "name_suffix", name_suffix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns only resources that exactly match this name. If no options are passed it will return all resources. Only one option can be used at a time.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameContains")
    def name_contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Match when the value exist in the name of the resource.
        """
        return pulumi.get(self, "name_contains")

    @name_contains.setter
    def name_contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_contains", value)

    @_builtins.property
    @pulumi.getter(name="nameExclude")
    def name_exclude(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Match when the exact value does not exist in the name of the resource.
        """
        return pulumi.get(self, "name_exclude")

    @name_exclude.setter
    def name_exclude(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_exclude", value)

    @_builtins.property
    @pulumi.getter(name="namePrefix")
    def name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource must start with the value.
        """
        return pulumi.get(self, "name_prefix")

    @name_prefix.setter
    def name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_prefix", value)

    @_builtins.property
    @pulumi.getter(name="nameRegexp")
    def name_regexp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The regular expression match of the name of the resource.
        """
        return pulumi.get(self, "name_regexp")

    @name_regexp.setter
    def name_regexp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_regexp", value)

    @_builtins.property
    @pulumi.getter(name="nameSuffix")
    def name_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource must end with the value.
        """
        return pulumi.get(self, "name_suffix")

    @name_suffix.setter
    def name_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_suffix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Returns only resources that exactly match the given tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ProviderDefaultTagsArgsDict(TypedDict):
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A map of key-value pair tags to be set on all resources by default.
        """
elif False:
    ProviderDefaultTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderDefaultTagsArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: A map of key-value pair tags to be set on all resources by default.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A map of key-value pair tags to be set on all resources by default.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class TwingateDNSFilteringProfileAllowedDomainsArgsDict(TypedDict):
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A set of allowed domains. Defaults to an empty set.
        """
        is_authoritative: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TwingateDNSFilteringProfileAllowedDomainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateDNSFilteringProfileAllowedDomainsArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_authoritative: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] domains: A set of allowed domains. Defaults to an empty set.
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if is_authoritative is not None:
            pulumi.set(__self__, "is_authoritative", is_authoritative)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A set of allowed domains. Defaults to an empty set.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "domains", value)

    @_builtins.property
    @pulumi.getter(name="isAuthoritative")
    def is_authoritative(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_authoritative")

    @is_authoritative.setter
    def is_authoritative(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authoritative", value)


if not MYPY:
    class TwingateDNSFilteringProfileContentCategoriesArgsDict(TypedDict):
        block_adult_content: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block adult content. Defaults to false.
        """
        block_dating: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block dating content. Defaults to false.
        """
        block_gambling: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block gambling content. Defaults to false.
        """
        block_games: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block games. Defaults to false.
        """
        block_piracy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block piracy sites. Defaults to false.
        """
        block_social_media: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block social media. Defaults to false.
        """
        block_streaming: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block streaming content. Defaults to false.
        """
        enable_safesearch: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to force safe search. Defaults to false.
        """
        enable_youtube_restricted_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to force YouTube to use restricted mode. Defaults to false.
        """
elif False:
    TwingateDNSFilteringProfileContentCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateDNSFilteringProfileContentCategoriesArgs:
    def __init__(__self__, *,
                 block_adult_content: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_dating: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_gambling: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_games: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_piracy: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_social_media: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_streaming: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_safesearch: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_youtube_restricted_mode: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_adult_content: Whether to block adult content. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_dating: Whether to block dating content. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_gambling: Whether to block gambling content. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_games: Whether to block games. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_piracy: Whether to block piracy sites. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_social_media: Whether to block social media. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_streaming: Whether to block streaming content. Defaults to false.
        :param pulumi.Input[_builtins.bool] enable_safesearch: Whether to force safe search. Defaults to false.
        :param pulumi.Input[_builtins.bool] enable_youtube_restricted_mode: Whether to force YouTube to use restricted mode. Defaults to false.
        """
        if block_adult_content is not None:
            pulumi.set(__self__, "block_adult_content", block_adult_content)
        if block_dating is not None:
            pulumi.set(__self__, "block_dating", block_dating)
        if block_gambling is not None:
            pulumi.set(__self__, "block_gambling", block_gambling)
        if block_games is not None:
            pulumi.set(__self__, "block_games", block_games)
        if block_piracy is not None:
            pulumi.set(__self__, "block_piracy", block_piracy)
        if block_social_media is not None:
            pulumi.set(__self__, "block_social_media", block_social_media)
        if block_streaming is not None:
            pulumi.set(__self__, "block_streaming", block_streaming)
        if enable_safesearch is not None:
            pulumi.set(__self__, "enable_safesearch", enable_safesearch)
        if enable_youtube_restricted_mode is not None:
            pulumi.set(__self__, "enable_youtube_restricted_mode", enable_youtube_restricted_mode)

    @_builtins.property
    @pulumi.getter(name="blockAdultContent")
    def block_adult_content(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block adult content. Defaults to false.
        """
        return pulumi.get(self, "block_adult_content")

    @block_adult_content.setter
    def block_adult_content(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_adult_content", value)

    @_builtins.property
    @pulumi.getter(name="blockDating")
    def block_dating(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block dating content. Defaults to false.
        """
        return pulumi.get(self, "block_dating")

    @block_dating.setter
    def block_dating(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_dating", value)

    @_builtins.property
    @pulumi.getter(name="blockGambling")
    def block_gambling(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block gambling content. Defaults to false.
        """
        return pulumi.get(self, "block_gambling")

    @block_gambling.setter
    def block_gambling(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_gambling", value)

    @_builtins.property
    @pulumi.getter(name="blockGames")
    def block_games(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block games. Defaults to false.
        """
        return pulumi.get(self, "block_games")

    @block_games.setter
    def block_games(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_games", value)

    @_builtins.property
    @pulumi.getter(name="blockPiracy")
    def block_piracy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block piracy sites. Defaults to false.
        """
        return pulumi.get(self, "block_piracy")

    @block_piracy.setter
    def block_piracy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_piracy", value)

    @_builtins.property
    @pulumi.getter(name="blockSocialMedia")
    def block_social_media(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block social media. Defaults to false.
        """
        return pulumi.get(self, "block_social_media")

    @block_social_media.setter
    def block_social_media(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_social_media", value)

    @_builtins.property
    @pulumi.getter(name="blockStreaming")
    def block_streaming(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block streaming content. Defaults to false.
        """
        return pulumi.get(self, "block_streaming")

    @block_streaming.setter
    def block_streaming(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_streaming", value)

    @_builtins.property
    @pulumi.getter(name="enableSafesearch")
    def enable_safesearch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to force safe search. Defaults to false.
        """
        return pulumi.get(self, "enable_safesearch")

    @enable_safesearch.setter
    def enable_safesearch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_safesearch", value)

    @_builtins.property
    @pulumi.getter(name="enableYoutubeRestrictedMode")
    def enable_youtube_restricted_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to force YouTube to use restricted mode. Defaults to false.
        """
        return pulumi.get(self, "enable_youtube_restricted_mode")

    @enable_youtube_restricted_mode.setter
    def enable_youtube_restricted_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_youtube_restricted_mode", value)


if not MYPY:
    class TwingateDNSFilteringProfileDeniedDomainsArgsDict(TypedDict):
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A set of denied domains. Defaults to an empty set.
        """
        is_authoritative: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TwingateDNSFilteringProfileDeniedDomainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateDNSFilteringProfileDeniedDomainsArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_authoritative: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] domains: A set of denied domains. Defaults to an empty set.
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if is_authoritative is not None:
            pulumi.set(__self__, "is_authoritative", is_authoritative)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A set of denied domains. Defaults to an empty set.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "domains", value)

    @_builtins.property
    @pulumi.getter(name="isAuthoritative")
    def is_authoritative(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_authoritative")

    @is_authoritative.setter
    def is_authoritative(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_authoritative", value)


if not MYPY:
    class TwingateDNSFilteringProfilePrivacyCategoriesArgsDict(TypedDict):
        block_ads_and_trackers: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block ads and trackers. Defaults to false.
        """
        block_affiliate_links: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block affiliate links. Defaults to false.
        """
        block_disguised_trackers: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block disguised third party trackers. Defaults to false.
        """
elif False:
    TwingateDNSFilteringProfilePrivacyCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateDNSFilteringProfilePrivacyCategoriesArgs:
    def __init__(__self__, *,
                 block_ads_and_trackers: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_affiliate_links: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_disguised_trackers: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_ads_and_trackers: Whether to block ads and trackers. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_affiliate_links: Whether to block affiliate links. Defaults to false.
        :param pulumi.Input[_builtins.bool] block_disguised_trackers: Whether to block disguised third party trackers. Defaults to false.
        """
        if block_ads_and_trackers is not None:
            pulumi.set(__self__, "block_ads_and_trackers", block_ads_and_trackers)
        if block_affiliate_links is not None:
            pulumi.set(__self__, "block_affiliate_links", block_affiliate_links)
        if block_disguised_trackers is not None:
            pulumi.set(__self__, "block_disguised_trackers", block_disguised_trackers)

    @_builtins.property
    @pulumi.getter(name="blockAdsAndTrackers")
    def block_ads_and_trackers(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block ads and trackers. Defaults to false.
        """
        return pulumi.get(self, "block_ads_and_trackers")

    @block_ads_and_trackers.setter
    def block_ads_and_trackers(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_ads_and_trackers", value)

    @_builtins.property
    @pulumi.getter(name="blockAffiliateLinks")
    def block_affiliate_links(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block affiliate links. Defaults to false.
        """
        return pulumi.get(self, "block_affiliate_links")

    @block_affiliate_links.setter
    def block_affiliate_links(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_affiliate_links", value)

    @_builtins.property
    @pulumi.getter(name="blockDisguisedTrackers")
    def block_disguised_trackers(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block disguised third party trackers. Defaults to false.
        """
        return pulumi.get(self, "block_disguised_trackers")

    @block_disguised_trackers.setter
    def block_disguised_trackers(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_disguised_trackers", value)


if not MYPY:
    class TwingateDNSFilteringProfileSecurityCategoriesArgsDict(TypedDict):
        block_cryptojacking: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block cryptojacking sites. Defaults to true.
        """
        block_dns_rebinding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Blocks public DNS entries from returning private IP addresses. Defaults to true.
        """
        block_domain_generation_algorithms: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Blocks DGA domains. Defaults to true.
        """
        block_idn_homoglyph: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to block homoglyph attacks. Defaults to true.
        """
        block_newly_registered_domains: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Blocks newly registered domains. Defaults to true.
        """
        block_parked_domains: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block parked domains. Defaults to true.
        """
        block_typosquatting: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Blocks typosquatted domains. Defaults to true.
        """
        enable_google_safe_browsing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use Google Safe browsing lists to block content. Defaults to true.
        """
        enable_threat_intelligence_feeds: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to filter content using threat intelligence feeds. Defaults to true.
        """
elif False:
    TwingateDNSFilteringProfileSecurityCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateDNSFilteringProfileSecurityCategoriesArgs:
    def __init__(__self__, *,
                 block_cryptojacking: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_dns_rebinding: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_domain_generation_algorithms: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_idn_homoglyph: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_newly_registered_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_parked_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_typosquatting: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_google_safe_browsing: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_threat_intelligence_feeds: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_cryptojacking: Whether to block cryptojacking sites. Defaults to true.
        :param pulumi.Input[_builtins.bool] block_dns_rebinding: Blocks public DNS entries from returning private IP addresses. Defaults to true.
        :param pulumi.Input[_builtins.bool] block_domain_generation_algorithms: Blocks DGA domains. Defaults to true.
        :param pulumi.Input[_builtins.bool] block_idn_homoglyph: Whether to block homoglyph attacks. Defaults to true.
        :param pulumi.Input[_builtins.bool] block_newly_registered_domains: Blocks newly registered domains. Defaults to true.
        :param pulumi.Input[_builtins.bool] block_parked_domains: Block parked domains. Defaults to true.
        :param pulumi.Input[_builtins.bool] block_typosquatting: Blocks typosquatted domains. Defaults to true.
        :param pulumi.Input[_builtins.bool] enable_google_safe_browsing: Whether to use Google Safe browsing lists to block content. Defaults to true.
        :param pulumi.Input[_builtins.bool] enable_threat_intelligence_feeds: Whether to filter content using threat intelligence feeds. Defaults to true.
        """
        if block_cryptojacking is not None:
            pulumi.set(__self__, "block_cryptojacking", block_cryptojacking)
        if block_dns_rebinding is not None:
            pulumi.set(__self__, "block_dns_rebinding", block_dns_rebinding)
        if block_domain_generation_algorithms is not None:
            pulumi.set(__self__, "block_domain_generation_algorithms", block_domain_generation_algorithms)
        if block_idn_homoglyph is not None:
            pulumi.set(__self__, "block_idn_homoglyph", block_idn_homoglyph)
        if block_newly_registered_domains is not None:
            pulumi.set(__self__, "block_newly_registered_domains", block_newly_registered_domains)
        if block_parked_domains is not None:
            pulumi.set(__self__, "block_parked_domains", block_parked_domains)
        if block_typosquatting is not None:
            pulumi.set(__self__, "block_typosquatting", block_typosquatting)
        if enable_google_safe_browsing is not None:
            pulumi.set(__self__, "enable_google_safe_browsing", enable_google_safe_browsing)
        if enable_threat_intelligence_feeds is not None:
            pulumi.set(__self__, "enable_threat_intelligence_feeds", enable_threat_intelligence_feeds)

    @_builtins.property
    @pulumi.getter(name="blockCryptojacking")
    def block_cryptojacking(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block cryptojacking sites. Defaults to true.
        """
        return pulumi.get(self, "block_cryptojacking")

    @block_cryptojacking.setter
    def block_cryptojacking(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_cryptojacking", value)

    @_builtins.property
    @pulumi.getter(name="blockDnsRebinding")
    def block_dns_rebinding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Blocks public DNS entries from returning private IP addresses. Defaults to true.
        """
        return pulumi.get(self, "block_dns_rebinding")

    @block_dns_rebinding.setter
    def block_dns_rebinding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_dns_rebinding", value)

    @_builtins.property
    @pulumi.getter(name="blockDomainGenerationAlgorithms")
    def block_domain_generation_algorithms(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Blocks DGA domains. Defaults to true.
        """
        return pulumi.get(self, "block_domain_generation_algorithms")

    @block_domain_generation_algorithms.setter
    def block_domain_generation_algorithms(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_domain_generation_algorithms", value)

    @_builtins.property
    @pulumi.getter(name="blockIdnHomoglyph")
    def block_idn_homoglyph(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to block homoglyph attacks. Defaults to true.
        """
        return pulumi.get(self, "block_idn_homoglyph")

    @block_idn_homoglyph.setter
    def block_idn_homoglyph(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_idn_homoglyph", value)

    @_builtins.property
    @pulumi.getter(name="blockNewlyRegisteredDomains")
    def block_newly_registered_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Blocks newly registered domains. Defaults to true.
        """
        return pulumi.get(self, "block_newly_registered_domains")

    @block_newly_registered_domains.setter
    def block_newly_registered_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_newly_registered_domains", value)

    @_builtins.property
    @pulumi.getter(name="blockParkedDomains")
    def block_parked_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block parked domains. Defaults to true.
        """
        return pulumi.get(self, "block_parked_domains")

    @block_parked_domains.setter
    def block_parked_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_parked_domains", value)

    @_builtins.property
    @pulumi.getter(name="blockTyposquatting")
    def block_typosquatting(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Blocks typosquatted domains. Defaults to true.
        """
        return pulumi.get(self, "block_typosquatting")

    @block_typosquatting.setter
    def block_typosquatting(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_typosquatting", value)

    @_builtins.property
    @pulumi.getter(name="enableGoogleSafeBrowsing")
    def enable_google_safe_browsing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use Google Safe browsing lists to block content. Defaults to true.
        """
        return pulumi.get(self, "enable_google_safe_browsing")

    @enable_google_safe_browsing.setter
    def enable_google_safe_browsing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_google_safe_browsing", value)

    @_builtins.property
    @pulumi.getter(name="enableThreatIntelligenceFeeds")
    def enable_threat_intelligence_feeds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to filter content using threat intelligence feeds. Defaults to true.
        """
        return pulumi.get(self, "enable_threat_intelligence_feeds")

    @enable_threat_intelligence_feeds.setter
    def enable_threat_intelligence_feeds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_threat_intelligence_feeds", value)


if not MYPY:
    class TwingateResourceAccessGroupArgsDict(TypedDict):
        access_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['TwingateResourceAccessGroupAccessPolicyArgsDict']]]]
        """
        Restrict access according to JIT access policy
        """
        approval_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        """
        group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group ID that will have permission to access the Resource.
        """
        security_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of a `get_twingate_security_policy` to use as the access policy for the group IDs in the access block.
        """
        usage_based_autolock_duration_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The usage-based auto-lock duration configured on the edge (in days).
        """
elif False:
    TwingateResourceAccessGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateResourceAccessGroupArgs:
    def __init__(__self__, *,
                 access_policies: Optional[pulumi.Input[Sequence[pulumi.Input['TwingateResourceAccessGroupAccessPolicyArgs']]]] = None,
                 approval_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 usage_based_autolock_duration_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TwingateResourceAccessGroupAccessPolicyArgs']]] access_policies: Restrict access according to JIT access policy
        :param pulumi.Input[_builtins.str] approval_mode: This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        :param pulumi.Input[_builtins.str] group_id: Group ID that will have permission to access the Resource.
        :param pulumi.Input[_builtins.str] security_policy_id: The ID of a `get_twingate_security_policy` to use as the access policy for the group IDs in the access block.
        :param pulumi.Input[_builtins.int] usage_based_autolock_duration_days: The usage-based auto-lock duration configured on the edge (in days).
        """
        if access_policies is not None:
            pulumi.set(__self__, "access_policies", access_policies)
        if approval_mode is not None:
            warnings.warn("""Configure access_policy instead. This attribute will be removed in the next major version of the provider.""", DeprecationWarning)
            pulumi.log.warn("""approval_mode is deprecated: Configure access_policy instead. This attribute will be removed in the next major version of the provider.""")
        if approval_mode is not None:
            pulumi.set(__self__, "approval_mode", approval_mode)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if security_policy_id is not None:
            pulumi.set(__self__, "security_policy_id", security_policy_id)
        if usage_based_autolock_duration_days is not None:
            warnings.warn("""Configure access_policy instead. This attribute will be removed in the next major version of the provider.""", DeprecationWarning)
            pulumi.log.warn("""usage_based_autolock_duration_days is deprecated: Configure access_policy instead. This attribute will be removed in the next major version of the provider.""")
        if usage_based_autolock_duration_days is not None:
            pulumi.set(__self__, "usage_based_autolock_duration_days", usage_based_autolock_duration_days)

    @_builtins.property
    @pulumi.getter(name="accessPolicies")
    def access_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TwingateResourceAccessGroupAccessPolicyArgs']]]]:
        """
        Restrict access according to JIT access policy
        """
        return pulumi.get(self, "access_policies")

    @access_policies.setter
    def access_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TwingateResourceAccessGroupAccessPolicyArgs']]]]):
        pulumi.set(self, "access_policies", value)

    @_builtins.property
    @pulumi.getter(name="approvalMode")
    @_utilities.deprecated("""Configure access_policy instead. This attribute will be removed in the next major version of the provider.""")
    def approval_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        """
        return pulumi.get(self, "approval_mode")

    @approval_mode.setter
    def approval_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_mode", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group ID that will have permission to access the Resource.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="securityPolicyId")
    def security_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of a `get_twingate_security_policy` to use as the access policy for the group IDs in the access block.
        """
        return pulumi.get(self, "security_policy_id")

    @security_policy_id.setter
    def security_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="usageBasedAutolockDurationDays")
    @_utilities.deprecated("""Configure access_policy instead. This attribute will be removed in the next major version of the provider.""")
    def usage_based_autolock_duration_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The usage-based auto-lock duration configured on the edge (in days).
        """
        return pulumi.get(self, "usage_based_autolock_duration_days")

    @usage_based_autolock_duration_days.setter
    def usage_based_autolock_duration_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "usage_based_autolock_duration_days", value)


if not MYPY:
    class TwingateResourceAccessGroupAccessPolicyArgsDict(TypedDict):
        approval_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        """
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        This will set the access duration on the edge. Duration must be between 1 hour and 365 days. The valid values are like `1h` and `2d`.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        This will set the access_policy mode on the edge. The valid values are `MANUAL`, `AUTO_LOCK` and `ACCESS_REQUEST`.
        """
elif False:
    TwingateResourceAccessGroupAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateResourceAccessGroupAccessPolicyArgs:
    def __init__(__self__, *,
                 approval_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_mode: This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        :param pulumi.Input[_builtins.str] duration: This will set the access duration on the edge. Duration must be between 1 hour and 365 days. The valid values are like `1h` and `2d`.
        :param pulumi.Input[_builtins.str] mode: This will set the access_policy mode on the edge. The valid values are `MANUAL`, `AUTO_LOCK` and `ACCESS_REQUEST`.
        """
        if approval_mode is not None:
            pulumi.set(__self__, "approval_mode", approval_mode)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="approvalMode")
    def approval_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        """
        return pulumi.get(self, "approval_mode")

    @approval_mode.setter
    def approval_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_mode", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This will set the access duration on the edge. Duration must be between 1 hour and 365 days. The valid values are like `1h` and `2d`.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This will set the access_policy mode on the edge. The valid values are `MANUAL`, `AUTO_LOCK` and `ACCESS_REQUEST`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class TwingateResourceAccessPolicyArgsDict(TypedDict):
        approval_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        """
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        This will set the access duration on the edge. Duration must be between 1 hour and 365 days. The valid values are like `1h` and `2d`.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        This will set the access_policy mode on the edge. The valid values are `MANUAL`, `AUTO_LOCK` and `ACCESS_REQUEST`.
        """
elif False:
    TwingateResourceAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateResourceAccessPolicyArgs:
    def __init__(__self__, *,
                 approval_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] approval_mode: This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        :param pulumi.Input[_builtins.str] duration: This will set the access duration on the edge. Duration must be between 1 hour and 365 days. The valid values are like `1h` and `2d`.
        :param pulumi.Input[_builtins.str] mode: This will set the access_policy mode on the edge. The valid values are `MANUAL`, `AUTO_LOCK` and `ACCESS_REQUEST`.
        """
        if approval_mode is not None:
            pulumi.set(__self__, "approval_mode", approval_mode)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="approvalMode")
    def approval_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This will set the approval model on the edge. The valid values are `AUTOMATIC` and `MANUAL`.
        """
        return pulumi.get(self, "approval_mode")

    @approval_mode.setter
    def approval_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_mode", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This will set the access duration on the edge. Duration must be between 1 hour and 365 days. The valid values are like `1h` and `2d`.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This will set the access_policy mode on the edge. The valid values are `MANUAL`, `AUTO_LOCK` and `ACCESS_REQUEST`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class TwingateResourceAccessServiceArgsDict(TypedDict):
        service_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the service account that should have access to this Resource.
        """
elif False:
    TwingateResourceAccessServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateResourceAccessServiceArgs:
    def __init__(__self__, *,
                 service_account_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_account_id: The ID of the service account that should have access to this Resource.
        """
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the service account that should have access to this Resource.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class TwingateResourceProtocolsArgsDict(TypedDict):
        allow_icmp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow ICMP (ping) traffic
        """
        tcp: NotRequired[pulumi.Input['TwingateResourceProtocolsTcpArgsDict']]
        udp: NotRequired[pulumi.Input['TwingateResourceProtocolsUdpArgsDict']]
elif False:
    TwingateResourceProtocolsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateResourceProtocolsArgs:
    def __init__(__self__, *,
                 allow_icmp: Optional[pulumi.Input[_builtins.bool]] = None,
                 tcp: Optional[pulumi.Input['TwingateResourceProtocolsTcpArgs']] = None,
                 udp: Optional[pulumi.Input['TwingateResourceProtocolsUdpArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_icmp: Whether to allow ICMP (ping) traffic
        """
        if allow_icmp is not None:
            pulumi.set(__self__, "allow_icmp", allow_icmp)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter(name="allowIcmp")
    def allow_icmp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow ICMP (ping) traffic
        """
        return pulumi.get(self, "allow_icmp")

    @allow_icmp.setter
    def allow_icmp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_icmp", value)

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['TwingateResourceProtocolsTcpArgs']]:
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['TwingateResourceProtocolsTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['TwingateResourceProtocolsUdpArgs']]:
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['TwingateResourceProtocolsUdpArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class TwingateResourceProtocolsTcpArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
elif False:
    TwingateResourceProtocolsTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateResourceProtocolsTcpArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] policy: Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ports: List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class TwingateResourceProtocolsUdpArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
elif False:
    TwingateResourceProtocolsUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwingateResourceProtocolsUdpArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] policy: Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ports: List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class GetTwingateDNSFilteringProfileAllowedDomainsArgsDict(TypedDict):
        domains: Sequence[_builtins.str]
        """
        A set of allowed domains.
        """
elif False:
    GetTwingateDNSFilteringProfileAllowedDomainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateDNSFilteringProfileAllowedDomainsArgs:
    def __init__(__self__, *,
                 domains: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] domains: A set of allowed domains.
        """
        pulumi.set(__self__, "domains", domains)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Sequence[_builtins.str]:
        """
        A set of allowed domains.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "domains", value)


if not MYPY:
    class GetTwingateDNSFilteringProfileContentCategoriesArgsDict(TypedDict):
        block_adult_content: _builtins.bool
        """
        Whether to block adult content.
        """
        block_dating: _builtins.bool
        """
        Whether to block dating content.
        """
        block_gambling: _builtins.bool
        """
        Whether to block gambling content.
        """
        block_games: _builtins.bool
        """
        Whether to block games.
        """
        block_piracy: _builtins.bool
        """
        Whether to block piracy sites.
        """
        block_social_media: _builtins.bool
        """
        Whether to block social media.
        """
        block_streaming: _builtins.bool
        """
        Whether to block streaming content.
        """
        enable_safesearch: _builtins.bool
        """
        Whether to force safe search.
        """
        enable_youtube_restricted_mode: _builtins.bool
        """
        Whether to force YouTube to use restricted mode.
        """
elif False:
    GetTwingateDNSFilteringProfileContentCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateDNSFilteringProfileContentCategoriesArgs:
    def __init__(__self__, *,
                 block_adult_content: _builtins.bool,
                 block_dating: _builtins.bool,
                 block_gambling: _builtins.bool,
                 block_games: _builtins.bool,
                 block_piracy: _builtins.bool,
                 block_social_media: _builtins.bool,
                 block_streaming: _builtins.bool,
                 enable_safesearch: _builtins.bool,
                 enable_youtube_restricted_mode: _builtins.bool):
        """
        :param _builtins.bool block_adult_content: Whether to block adult content.
        :param _builtins.bool block_dating: Whether to block dating content.
        :param _builtins.bool block_gambling: Whether to block gambling content.
        :param _builtins.bool block_games: Whether to block games.
        :param _builtins.bool block_piracy: Whether to block piracy sites.
        :param _builtins.bool block_social_media: Whether to block social media.
        :param _builtins.bool block_streaming: Whether to block streaming content.
        :param _builtins.bool enable_safesearch: Whether to force safe search.
        :param _builtins.bool enable_youtube_restricted_mode: Whether to force YouTube to use restricted mode.
        """
        pulumi.set(__self__, "block_adult_content", block_adult_content)
        pulumi.set(__self__, "block_dating", block_dating)
        pulumi.set(__self__, "block_gambling", block_gambling)
        pulumi.set(__self__, "block_games", block_games)
        pulumi.set(__self__, "block_piracy", block_piracy)
        pulumi.set(__self__, "block_social_media", block_social_media)
        pulumi.set(__self__, "block_streaming", block_streaming)
        pulumi.set(__self__, "enable_safesearch", enable_safesearch)
        pulumi.set(__self__, "enable_youtube_restricted_mode", enable_youtube_restricted_mode)

    @_builtins.property
    @pulumi.getter(name="blockAdultContent")
    def block_adult_content(self) -> _builtins.bool:
        """
        Whether to block adult content.
        """
        return pulumi.get(self, "block_adult_content")

    @block_adult_content.setter
    def block_adult_content(self, value: _builtins.bool):
        pulumi.set(self, "block_adult_content", value)

    @_builtins.property
    @pulumi.getter(name="blockDating")
    def block_dating(self) -> _builtins.bool:
        """
        Whether to block dating content.
        """
        return pulumi.get(self, "block_dating")

    @block_dating.setter
    def block_dating(self, value: _builtins.bool):
        pulumi.set(self, "block_dating", value)

    @_builtins.property
    @pulumi.getter(name="blockGambling")
    def block_gambling(self) -> _builtins.bool:
        """
        Whether to block gambling content.
        """
        return pulumi.get(self, "block_gambling")

    @block_gambling.setter
    def block_gambling(self, value: _builtins.bool):
        pulumi.set(self, "block_gambling", value)

    @_builtins.property
    @pulumi.getter(name="blockGames")
    def block_games(self) -> _builtins.bool:
        """
        Whether to block games.
        """
        return pulumi.get(self, "block_games")

    @block_games.setter
    def block_games(self, value: _builtins.bool):
        pulumi.set(self, "block_games", value)

    @_builtins.property
    @pulumi.getter(name="blockPiracy")
    def block_piracy(self) -> _builtins.bool:
        """
        Whether to block piracy sites.
        """
        return pulumi.get(self, "block_piracy")

    @block_piracy.setter
    def block_piracy(self, value: _builtins.bool):
        pulumi.set(self, "block_piracy", value)

    @_builtins.property
    @pulumi.getter(name="blockSocialMedia")
    def block_social_media(self) -> _builtins.bool:
        """
        Whether to block social media.
        """
        return pulumi.get(self, "block_social_media")

    @block_social_media.setter
    def block_social_media(self, value: _builtins.bool):
        pulumi.set(self, "block_social_media", value)

    @_builtins.property
    @pulumi.getter(name="blockStreaming")
    def block_streaming(self) -> _builtins.bool:
        """
        Whether to block streaming content.
        """
        return pulumi.get(self, "block_streaming")

    @block_streaming.setter
    def block_streaming(self, value: _builtins.bool):
        pulumi.set(self, "block_streaming", value)

    @_builtins.property
    @pulumi.getter(name="enableSafesearch")
    def enable_safesearch(self) -> _builtins.bool:
        """
        Whether to force safe search.
        """
        return pulumi.get(self, "enable_safesearch")

    @enable_safesearch.setter
    def enable_safesearch(self, value: _builtins.bool):
        pulumi.set(self, "enable_safesearch", value)

    @_builtins.property
    @pulumi.getter(name="enableYoutubeRestrictedMode")
    def enable_youtube_restricted_mode(self) -> _builtins.bool:
        """
        Whether to force YouTube to use restricted mode.
        """
        return pulumi.get(self, "enable_youtube_restricted_mode")

    @enable_youtube_restricted_mode.setter
    def enable_youtube_restricted_mode(self, value: _builtins.bool):
        pulumi.set(self, "enable_youtube_restricted_mode", value)


if not MYPY:
    class GetTwingateDNSFilteringProfileDeniedDomainsArgsDict(TypedDict):
        domains: Sequence[_builtins.str]
        """
        A set of denied domains.
        """
elif False:
    GetTwingateDNSFilteringProfileDeniedDomainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateDNSFilteringProfileDeniedDomainsArgs:
    def __init__(__self__, *,
                 domains: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] domains: A set of denied domains.
        """
        pulumi.set(__self__, "domains", domains)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Sequence[_builtins.str]:
        """
        A set of denied domains.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "domains", value)


if not MYPY:
    class GetTwingateDNSFilteringProfilePrivacyCategoriesArgsDict(TypedDict):
        block_ads_and_trackers: _builtins.bool
        """
        Whether to block ads and trackers.
        """
        block_affiliate_links: _builtins.bool
        """
        Whether to block affiliate links.
        """
        block_disguised_trackers: _builtins.bool
        """
        Whether to block disguised third party trackers.
        """
elif False:
    GetTwingateDNSFilteringProfilePrivacyCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateDNSFilteringProfilePrivacyCategoriesArgs:
    def __init__(__self__, *,
                 block_ads_and_trackers: _builtins.bool,
                 block_affiliate_links: _builtins.bool,
                 block_disguised_trackers: _builtins.bool):
        """
        :param _builtins.bool block_ads_and_trackers: Whether to block ads and trackers.
        :param _builtins.bool block_affiliate_links: Whether to block affiliate links.
        :param _builtins.bool block_disguised_trackers: Whether to block disguised third party trackers.
        """
        pulumi.set(__self__, "block_ads_and_trackers", block_ads_and_trackers)
        pulumi.set(__self__, "block_affiliate_links", block_affiliate_links)
        pulumi.set(__self__, "block_disguised_trackers", block_disguised_trackers)

    @_builtins.property
    @pulumi.getter(name="blockAdsAndTrackers")
    def block_ads_and_trackers(self) -> _builtins.bool:
        """
        Whether to block ads and trackers.
        """
        return pulumi.get(self, "block_ads_and_trackers")

    @block_ads_and_trackers.setter
    def block_ads_and_trackers(self, value: _builtins.bool):
        pulumi.set(self, "block_ads_and_trackers", value)

    @_builtins.property
    @pulumi.getter(name="blockAffiliateLinks")
    def block_affiliate_links(self) -> _builtins.bool:
        """
        Whether to block affiliate links.
        """
        return pulumi.get(self, "block_affiliate_links")

    @block_affiliate_links.setter
    def block_affiliate_links(self, value: _builtins.bool):
        pulumi.set(self, "block_affiliate_links", value)

    @_builtins.property
    @pulumi.getter(name="blockDisguisedTrackers")
    def block_disguised_trackers(self) -> _builtins.bool:
        """
        Whether to block disguised third party trackers.
        """
        return pulumi.get(self, "block_disguised_trackers")

    @block_disguised_trackers.setter
    def block_disguised_trackers(self, value: _builtins.bool):
        pulumi.set(self, "block_disguised_trackers", value)


if not MYPY:
    class GetTwingateDNSFilteringProfileSecurityCategoriesArgsDict(TypedDict):
        block_cryptojacking: _builtins.bool
        """
        Whether to block cryptojacking sites.
        """
        block_dns_rebinding: _builtins.bool
        """
        Blocks public DNS entries from returning private IP addresses.
        """
        block_domain_generation_algorithms: _builtins.bool
        """
        Blocks DGA domains.
        """
        block_idn_homoglyph: _builtins.bool
        """
        Whether to block homoglyph attacks.
        """
        block_newly_registered_domains: _builtins.bool
        """
        Blocks newly registered domains.
        """
        block_parked_domains: _builtins.bool
        """
        Block parked domains.
        """
        block_typosquatting: _builtins.bool
        """
        Blocks typosquatted domains.
        """
        enable_google_safe_browsing: _builtins.bool
        """
        Whether to use Google Safe browsing lists to block content.
        """
        enable_threat_intelligence_feeds: _builtins.bool
        """
        Whether to filter content using threat intelligence feeds.
        """
elif False:
    GetTwingateDNSFilteringProfileSecurityCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateDNSFilteringProfileSecurityCategoriesArgs:
    def __init__(__self__, *,
                 block_cryptojacking: _builtins.bool,
                 block_dns_rebinding: _builtins.bool,
                 block_domain_generation_algorithms: _builtins.bool,
                 block_idn_homoglyph: _builtins.bool,
                 block_newly_registered_domains: _builtins.bool,
                 block_parked_domains: _builtins.bool,
                 block_typosquatting: _builtins.bool,
                 enable_google_safe_browsing: _builtins.bool,
                 enable_threat_intelligence_feeds: _builtins.bool):
        """
        :param _builtins.bool block_cryptojacking: Whether to block cryptojacking sites.
        :param _builtins.bool block_dns_rebinding: Blocks public DNS entries from returning private IP addresses.
        :param _builtins.bool block_domain_generation_algorithms: Blocks DGA domains.
        :param _builtins.bool block_idn_homoglyph: Whether to block homoglyph attacks.
        :param _builtins.bool block_newly_registered_domains: Blocks newly registered domains.
        :param _builtins.bool block_parked_domains: Block parked domains.
        :param _builtins.bool block_typosquatting: Blocks typosquatted domains.
        :param _builtins.bool enable_google_safe_browsing: Whether to use Google Safe browsing lists to block content.
        :param _builtins.bool enable_threat_intelligence_feeds: Whether to filter content using threat intelligence feeds.
        """
        pulumi.set(__self__, "block_cryptojacking", block_cryptojacking)
        pulumi.set(__self__, "block_dns_rebinding", block_dns_rebinding)
        pulumi.set(__self__, "block_domain_generation_algorithms", block_domain_generation_algorithms)
        pulumi.set(__self__, "block_idn_homoglyph", block_idn_homoglyph)
        pulumi.set(__self__, "block_newly_registered_domains", block_newly_registered_domains)
        pulumi.set(__self__, "block_parked_domains", block_parked_domains)
        pulumi.set(__self__, "block_typosquatting", block_typosquatting)
        pulumi.set(__self__, "enable_google_safe_browsing", enable_google_safe_browsing)
        pulumi.set(__self__, "enable_threat_intelligence_feeds", enable_threat_intelligence_feeds)

    @_builtins.property
    @pulumi.getter(name="blockCryptojacking")
    def block_cryptojacking(self) -> _builtins.bool:
        """
        Whether to block cryptojacking sites.
        """
        return pulumi.get(self, "block_cryptojacking")

    @block_cryptojacking.setter
    def block_cryptojacking(self, value: _builtins.bool):
        pulumi.set(self, "block_cryptojacking", value)

    @_builtins.property
    @pulumi.getter(name="blockDnsRebinding")
    def block_dns_rebinding(self) -> _builtins.bool:
        """
        Blocks public DNS entries from returning private IP addresses.
        """
        return pulumi.get(self, "block_dns_rebinding")

    @block_dns_rebinding.setter
    def block_dns_rebinding(self, value: _builtins.bool):
        pulumi.set(self, "block_dns_rebinding", value)

    @_builtins.property
    @pulumi.getter(name="blockDomainGenerationAlgorithms")
    def block_domain_generation_algorithms(self) -> _builtins.bool:
        """
        Blocks DGA domains.
        """
        return pulumi.get(self, "block_domain_generation_algorithms")

    @block_domain_generation_algorithms.setter
    def block_domain_generation_algorithms(self, value: _builtins.bool):
        pulumi.set(self, "block_domain_generation_algorithms", value)

    @_builtins.property
    @pulumi.getter(name="blockIdnHomoglyph")
    def block_idn_homoglyph(self) -> _builtins.bool:
        """
        Whether to block homoglyph attacks.
        """
        return pulumi.get(self, "block_idn_homoglyph")

    @block_idn_homoglyph.setter
    def block_idn_homoglyph(self, value: _builtins.bool):
        pulumi.set(self, "block_idn_homoglyph", value)

    @_builtins.property
    @pulumi.getter(name="blockNewlyRegisteredDomains")
    def block_newly_registered_domains(self) -> _builtins.bool:
        """
        Blocks newly registered domains.
        """
        return pulumi.get(self, "block_newly_registered_domains")

    @block_newly_registered_domains.setter
    def block_newly_registered_domains(self, value: _builtins.bool):
        pulumi.set(self, "block_newly_registered_domains", value)

    @_builtins.property
    @pulumi.getter(name="blockParkedDomains")
    def block_parked_domains(self) -> _builtins.bool:
        """
        Block parked domains.
        """
        return pulumi.get(self, "block_parked_domains")

    @block_parked_domains.setter
    def block_parked_domains(self, value: _builtins.bool):
        pulumi.set(self, "block_parked_domains", value)

    @_builtins.property
    @pulumi.getter(name="blockTyposquatting")
    def block_typosquatting(self) -> _builtins.bool:
        """
        Blocks typosquatted domains.
        """
        return pulumi.get(self, "block_typosquatting")

    @block_typosquatting.setter
    def block_typosquatting(self, value: _builtins.bool):
        pulumi.set(self, "block_typosquatting", value)

    @_builtins.property
    @pulumi.getter(name="enableGoogleSafeBrowsing")
    def enable_google_safe_browsing(self) -> _builtins.bool:
        """
        Whether to use Google Safe browsing lists to block content.
        """
        return pulumi.get(self, "enable_google_safe_browsing")

    @enable_google_safe_browsing.setter
    def enable_google_safe_browsing(self, value: _builtins.bool):
        pulumi.set(self, "enable_google_safe_browsing", value)

    @_builtins.property
    @pulumi.getter(name="enableThreatIntelligenceFeeds")
    def enable_threat_intelligence_feeds(self) -> _builtins.bool:
        """
        Whether to filter content using threat intelligence feeds.
        """
        return pulumi.get(self, "enable_threat_intelligence_feeds")

    @enable_threat_intelligence_feeds.setter
    def enable_threat_intelligence_feeds(self, value: _builtins.bool):
        pulumi.set(self, "enable_threat_intelligence_feeds", value)


if not MYPY:
    class GetTwingateResourceProtocolsArgsDict(TypedDict):
        allow_icmp: _builtins.bool
        """
        Whether to allow ICMP (ping) traffic
        """
        tcp: NotRequired['GetTwingateResourceProtocolsTcpArgsDict']
        udp: NotRequired['GetTwingateResourceProtocolsUdpArgsDict']
elif False:
    GetTwingateResourceProtocolsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateResourceProtocolsArgs:
    def __init__(__self__, *,
                 allow_icmp: _builtins.bool,
                 tcp: Optional['GetTwingateResourceProtocolsTcpArgs'] = None,
                 udp: Optional['GetTwingateResourceProtocolsUdpArgs'] = None):
        """
        :param _builtins.bool allow_icmp: Whether to allow ICMP (ping) traffic
        """
        pulumi.set(__self__, "allow_icmp", allow_icmp)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @_builtins.property
    @pulumi.getter(name="allowIcmp")
    def allow_icmp(self) -> _builtins.bool:
        """
        Whether to allow ICMP (ping) traffic
        """
        return pulumi.get(self, "allow_icmp")

    @allow_icmp.setter
    def allow_icmp(self, value: _builtins.bool):
        pulumi.set(self, "allow_icmp", value)

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['GetTwingateResourceProtocolsTcpArgs']:
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional['GetTwingateResourceProtocolsTcpArgs']):
        pulumi.set(self, "tcp", value)

    @_builtins.property
    @pulumi.getter
    def udp(self) -> Optional['GetTwingateResourceProtocolsUdpArgs']:
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional['GetTwingateResourceProtocolsUdpArgs']):
        pulumi.set(self, "udp", value)


if not MYPY:
    class GetTwingateResourceProtocolsTcpArgsDict(TypedDict):
        policy: _builtins.str
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        ports: Sequence[_builtins.str]
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
elif False:
    GetTwingateResourceProtocolsTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateResourceProtocolsTcpArgs:
    def __init__(__self__, *,
                 policy: _builtins.str,
                 ports: Sequence[_builtins.str]):
        """
        :param _builtins.str policy: Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        :param Sequence[_builtins.str] ports: List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: _builtins.str):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence[_builtins.str]:
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class GetTwingateResourceProtocolsUdpArgsDict(TypedDict):
        policy: _builtins.str
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        ports: Sequence[_builtins.str]
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
elif False:
    GetTwingateResourceProtocolsUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTwingateResourceProtocolsUdpArgs:
    def __init__(__self__, *,
                 policy: _builtins.str,
                 ports: Sequence[_builtins.str]):
        """
        :param _builtins.str policy: Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        :param Sequence[_builtins.str] ports: List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        pulumi.set(__self__, "policy", policy)
        pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        Whether to allow or deny all ports, or restrict protocol access within certain port ranges: Can be `RESTRICTED` (only listed ports are allowed), `ALLOW_ALL`, or `DENY_ALL`
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: _builtins.str):
        pulumi.set(self, "policy", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence[_builtins.str]:
        """
        List of port ranges between 1 and 65535 inclusive, in the format `100-200` for a range, or `8080` for a single port
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "ports", value)


